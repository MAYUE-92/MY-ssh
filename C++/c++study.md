# 一、输入和输出

在c++中，通过cin、cout与scanf、printf，来完成输出和输出

## 1.1 cin与cout

cin>>代表从键盘输入数据，cout<<代表从显示端输出数据，输出要换行的话，必须以endl结尾，否则程序默认输出到一行

代码实例：

```c++
#include <iostream>

using namespace std;

int main()
{
    double x; //定义一个变量X
    cout << "请输入一个单位为g的数值：";
    cin >> x;
    cout << "换算结果等于：" << x*5 << "克拉,";
    cout << "等于：" << x/31.1034807 << "盎司" << endl;
    return 0;
}
```

## 1.2 scanf与printf

scanf和需要分别为变量指定格式符，scanf使用的是变量地址，cin>>直接用右移运算符赋值，且使用变量名即可；

printf和scanf一样是两个参数，第一个是格式花字符串，第二个是表达式，还需要指定表达式的字符串类型,cout<<可以直接是表达式，无需指定参数字符类型，程序自动识别。

```c++
#include <iostream>

using namespace std;

int main()
{   //scanf需要分别为变量指定格式符，scanf使用的是变量地址，cin直接用右移运算符赋值，且使用变量名即可
    int x; scanf(" %d", &x);  // 该方法等价于：cin>>x;
    float y; scanf("%d", &y); // 该方法等价于：cin>>y;
    double z; scanf("%lf", &z); // 该方法等价于：cin>>z;
    char ch; scanf("%c", &ch); // 该方法等价于：cin>>ch;
    char str[20]; scanf("%s", str); // 该方法等价于：cin>>str;

    scanf(" %d %f %lf %c %s", &x, &y, &z, &ch,str); //该方法等价于：cin>>x>>y>>z>>ch>>str
    return 0;
}

int main()
{
    //printf和scanf一样是两个参数，第一个是格式花字符串，第二个是表达式,cout可以直接是表达式，无需指定参数字符类型，程序自动识别
    int x = 10; printf("x+5", x+5); // 该方法等价于：cout<<"x+5"<<x+5
    float y = 5.5; printf("y+1=%f", y+1); // cout << "y+1" << y+1;
    double z = 5.5; printf("z=%lf", z); // cout<< "z" << z;
    char ch = "A"; printf("ch=%c", ch); // cout << "ch"<< ch;
    char str[20]="China"; printf("%s", str); // cout <<str;

    printf("%5d,%5.2f,%5.2lf,%5c,%5s",x,y,z,ch,str);
    //cout<<x<<","<<y<<","<<z<<","<<ch<<","<<str
}
```

## 1.3 变量初始化及常变量

c语言和c++在定义常变量和变量初始化的方法有区别，C语言是通过#define定义，c++是使用const关键字。方式如下：

```c++
# include <iostream>

using namespace std;

int main()
{
    /*
    c语言风格，将变量x,y初始化为int类型，其中x=10，
    y没有赋值，y的值可能是以前的程序遗留下的，是不确定的
    */
    int x=10,y;

    /*
    c++风格，使用面向对象的方式赋值
    */
   int x(10),y;

   return 0;
}

int main()
{
    /* 
    c语言的符号常量，例如定义pie的值为3.14
    */
   #define pie 3.14

    /* 
    c++语言引入了新的概念：常变量
    意思为初始化后数值不能改变的变量为常变量。
    1、使用const关键字定义
    2、定义常变量必须初始化
    3、常变量只能读取和显示，不能改变，不能被再次赋值
    */
   const int x=5;
   return 0;
}
```

# 二、引用及函数间参数的引用传递

## 2.1 访问变量内存单元

假设，已定义变量：int x = 10;

**通过变量名：** cout<<x;  通过访问变量x来获取值

**指针访问：** int *p; p = &x; cout<<(*p); 先定义一个int型指针p，通过p指向x内存单元，然通过读取cout(*p)去访问x所对应的内存单元，读出其中的数据。

```
int *p; p=&x; cout<<(*p);
```

**c++语言，引用访问：** int &xa = x; cout<<xa; 在c++中允许为已经定义的变量取一个别名，称为变量引用名，它是一个特殊变量称为引用变量，引用变量和其引用的变量公用一个内存单元，不会再单独分配内存空间。引用说明符和位与运算符都用&表示，&这个符号具有多意性，要根据实际情况进行区分，定义引用变量后，可以直接访问引用变量来访问引用的变量。

定义引用变量与定义普通变量方法类似，需要指定引用变量的字符串类型，需要和引用的变量类型一致；语法如下：

- 引用类型：引用变量的数据类型，必须和被引用的变量一致；
- 引用说明符：用&来申明；
- 引用变量名：需符合标识符的命名规则；
- 被引用变量名：指定被引用的变量名，必须是已经定义的变量；
- 初始化：定义引用变量必须指定是哪个变量的引用，引用变量只能引用一个变量，定义后不能再引用其他变量。

  ```c++
  int x =10;

  //定义引用变量
  int &xa = x; // 称xa是x的一个引用
  int x, int y; int &xa = x; //一条定义变量的语句即可包括普通变量，又包括引用变量
  ```

**变量的直接访问与间接访问**:通过变量名是直接访问，通过指针和引用变量的方式是间接访问。

## 2.2 运算符


| 运算符 | 描述 | 实例：假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：A = 0011 1100，B = 0000 1101 |
| - | - | - |
| & | 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。 | (A & B) 将得到 12，即为 0000 1100 |
| \| | 如果存在于任一操作数中，二进制  OR 运算符复制一位到结果中。 | (A\| B) 将得到  61，即为 0011 1101 |
| ^ | 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。 | (A ^ B) 将得到  49，即为 0011 0001 |
| ~ | 二进制补码运算符是一元运算符，具有"翻转"位效果，即0变成1，1变成0。 | (~A ) 将得到  -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| << | 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。 | A << 2  将得到 240，即为 1111 0000 |
| >> | 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。 | A >> 2  将得到 15，即为 0000 1111 |

## 2.3 函数间参数的传递

采用数据分散管理策略时，数据分散在各个函数中管理，函数各自定义局部变量，保存数据，其他函数不能直接访问，调用函数时，主调函数和被调函数之间，需要通过行使结合来传递数据，将保存在主调函数里的原始数据以实参的形式实现传递给被调函数的行参，就称为函数间的参数传递。

C语言提供了2种函数传递方式

- 值传递
- 指针传递

C++又新增了一种新的传递方式

- 引用传递

概念：引用传递就是传递实参变量的引用，被调函数通过引用，间接访问主调函数中的的变量，从而达到传递数据的目的。采用引用传递时，被调函数的行参，需定义成引用变量。

**例子：**定义2个变量：int x=5,y=10;编写好一个函数swap来交换这2个变量的数值。交换后，x的值应为10，y的值应为5。

```c++
#include <iostream>
using namespace std;

//定义被调函数 swap
void swap(int &a,int &b) // 引用传递：将形参定义为引用变量
{
    int t;
    t = a; a = b; b = t; //这3条语句可以交换a和b的值
}

//定义主调函数main
int main()
{
    cout << "Exchange x and y" << endl;
    int x = 5, y = 10;  //定义实参x，y
    cout << x << "," << y << endl;

    swap(x,y); //调用函数swap交换变量x和y的值
    cout << x << "," << y << endl;
    return 0;
}
```

被调函数修改形参实际上修改的时对应的实参，换句话说，主调函数可以通过引用将数据传递给被调函数，被调函数也可以通过该引用修改实参的值将数据传回主调函数，引用传递是一种双向传递机制。

**特别注意：**引用传递时实参必须是变量，不能是常量或者表达式。

**引用传递的好处：**一是形参直接引用实参，不需要分配内存来传递数值，这样可以提高函数调用速度，降低内存占用；二是可以通过引用实现双向数据传递。

### 1、形参和实参的含义

- 形参：全称为“形式参数”是在定义函bai数名和函数体的时候使用的参数，目的是用来接收调用该函数时传递的参数。形参的作用是实现主调函数与被调函数之间的联系，通常将函数所处理的数据，影响函数功能的因素或者函数处理的结果作为形参。没有形参的函数在形参表的位置应该写void.main 函数也可以有形参和返回值，其形参也称为命令行参数，由操作系统在启动程序时初始化，其返回值传递给操作系统。
- 实参：可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。

## 2.4 几种特殊形式的参数

C++新增了以下3种新的函数

### 1、带默认形参的函数

定义函数或声明函数原型时，可以指定形式参数的默认值，这就是带默认形式参数值的函数。调用默认形参值的函数时，如果给出实参值，则将实参值赋值给形参变量；如果没有则将默认值给形参变量。

**例子：**人民币汇率转换表（2015年6月19日）

| 外币（数量：1） | 人民币（单位：元） |
| --------------- | ------------------ |
| 美元            | 6.1104             |
| 欧元            | 6.9698             |
| 英镑            | 9.7347             |
| 港币            | 0.78817            |

```c++
#include <iostream>
using namespace std;

double Exchange(double amount=100,double rate=6.1104)
{
    return amount/rate;
}

int main()
{
    int x;
    cout <<"请输入人民数量，单位元：";
    cin >> x;
    cout<<x<<"元人民币="<<Exchange(x)<<"美元"<<endl; //人民币>>美元
    cout<<x<<"元人民币="<<Exchange(x,6.9698)<<"欧元"<<endl; //人民币>>欧元
    cout<<x<<"元人民币="<<Exchange(x,9.7347)<<"英镑"<<endl; //人民币>>英镑
    cout<<x<<"元人民币="<<Exchange(x,0.78817)<<"港币"<<endl; //人民币>>港币
    return 0;
}
```

**带默认形参值函数的语法细则：**

- 带默认值的形参
- 在函数原型声明中指定默认值
- 同一函数在不同的作用域中可以指定不同的默认值

```c++
#include <iostream>
using namespace std;

void fun(int p=10); //指定文件作用域的形参默认值：10

int main()
{
    fun(); //使用文件作用域的默认值，函数fun的显示结果：10
    /*
    定义一个新的块作用域（局部作用域）
    */
    {
        void fun(int p=20); //指定块作用域形参默认值：20
        fun(); //使用块作用域的默认值（局部优先），fun显示结果：20
    }
    return 0;
}

void fun(int p) //因为第五行已经指定了文件的作用域的默认值，此处不能再指定
{
    cout<<p<<endl; //显示形参p接收到的实际值
}
```

- 带默认值的形参必须定义在不带默认值的形式参数的后面，例如

  ```c++
  void fun(int p1 = 10,int p2 =20, int p3 =30); //正确
  void fun(int p1, int p2 =20, int p3 =30); //正确
  void fun(int p1 = 10,int p2 = 20,int ps); //错误写法
  void fun(int p1 = 10,int p2, int p3 =30); //错误写法
  ```


## 2、重载函数

**C语言中函数名不能重名：**

调用函数时，通过函数名指定调用哪个函数，函数名是函数的标识，通常同一文件中的函数名不能重名，不同文件中的非静态函数及外部函数之间也不能重名。

**C++语言重载函数：**

如果两个函数的形参不同，或数据类型不同，那么这两个函数就可以重名。重名函数被称为重载函数。

将两个或两个以上函数定义为重载函数的原因，是这些函数的**功能相同或相近，**使用相同的名字方便码农记忆，也不用绞尽脑子去想如何起不同的名字

```c++
#include <iostream>
using namespace std;
// Max为重载函数名，功能是求最大值。
int Max(int x,int y){return ((x>y)?x:y);}
//double型浮点类型，为64位宽度，float型为32位宽度
double Max(double x,double y){return ((x>y)?x:y);}
int Max(int x, int y, int z)
{
    int m;
    m = (x>y)?x:y;
    m = (x>z)?m:z;
    return m;
}

cout<<Max(9,5); //自动调用：int Max(int x,int y)
cout<<Max(9.0,5.0); //自动调用：double Max(double x,double y)
cout<<Max(9,5,17); //自动调用：int Max(int x, int y, int z)
```

C++在编译语言时，由编译器根据调用语句中实参的个数和类型，来自动调用形参最匹配的那个重载函数，简而言之就是通过形参和实参的匹配原则来调用重载函数。

**注意：**在应用重载函数时，如果两个函数仅仅是返回值类型不同或形参名不同，那么不能讲这两个函数命名为重载函数，否则会出现语法错误。也不能将两个功能差异很大的函数命名为重载函数，虽然没有语法错误，但是会在运用中给程序员造成混淆。

## 3、内联函数

**调用函数：**函数跳转和数据传递需要执行一些额外的操作，实现相同的功能，单一主函数程序比主函数+子函数程序执行速度更快，及函数跳转会降低程序的执行效率

**内联函数：**内联函数是一种特殊的函数，它在保障程序开发效率的同时，不会减低程序的执行效率。其原理是：编译源程序时将函数代码直接嵌入到每一个调用语句处，而在执行时不再进行函数跳转和数据传递。

```c++
#include <iostream>
using namespace std;

//使用inline关键字申明内联函数
inline double Exchange(double amount,double rate=6.1104)
{ return amount / rate; }


int main()
{
    int x;
    cout <<"请输入人民数量，单位元：";
    cin >> x;
    cout<<x<<"元人民币="<<Exchange(x)<<"美元"<<endl; //人民币>>美元
    cout<<x<<"元人民币="<<Exchange(x,6.9698)<<"欧元"<<endl; //人民币>>欧元
    cout<<x<<"元人民币="<<Exchange(x,9.7347)<<"英镑"<<endl; //人民币>>英镑
    cout<<x<<"元人民币="<<Exchange(x,0.78817)<<"港币"<<endl; //人民币>>港币
    return 0;
}
```

内联函数需要在被调用的函数前加上**inline**关键值进行申明。

内联函数需要是简单的函数，编译器不能保证程序员所定义或申明的内联函数最终都能按照内联的方式进行编译，如果该函数的函数体比较复杂，比如有循环语句，那么编译器将自动按照非内联函数的方式进行编译。

内联函数只有被多次调用，其执行效率才能体现出来，因此一般只是将频繁调用的简单函数，定义为内联函数。

# 三、命名空间

我们在编写程序时，可以使用各种渠道得到的函数，但是C语言和C++都规定，所有的外部函数不能重名，但我们在使用外来函数时，不同的机构不同的程序员开发的函数难免会重名，比如山东的德州和美国的德州，单独看德州两个字，这两个地方重名了，但是如果加上国度，这两个地方就能够准确的区分开来，这个国度就是命名空间的概念。

C++引入了命名空间的概念，不同的程序员在各自的命名空间内定义外部函数和全局变量，就可以消除重名的问题。

## 3.1 定义方式

在命名空间中定义函数和全局变量，使用namespace关键值进行申明。然后将函数和全局变量定义在其后的一对大括号{}之中。例子如下：

```c++
namespace Tom // 通过namespace进行申明一个名叫Tom的命名空间
{
    int x,y;
    void fun1(){......}
    void fun2(){......}
}
```

## 3.2 访问方式

访问命名空间中的函数和全局变量

### 1、直接访问

通过命名空间名称+双冒号::+全局变量标识符/函数名的方式进行访问：

```c++
Tom::x=10; Tom::y=20; //访问全局变量
Tom::fun1(); Tom::fun2(); //调用命名空间Tom里的函数
```

双冒号（::）称之为作用域运算符

### 2、使用关键字using先申明各个标识符的命名空间

也可以先声明各个标识符的命名空间，使用关键字using，如果事先声明了要访问的各个标识符，再访问的时候，可以省略命名空间名。

```c++
using Tom::x; //先声明各标识符的命名空间
using Tom::y;
using Tom::fun1();
using Tom::fun2();
x = 10; y = 20; //再通过标识符访问，访问时可以省略命名空间
fun1(); fun2();
```

### 3、统以申明命名空间的所有标识符

也可以先统一声明命名空间里的所有标识符，再通过标识符直接访问。

```c++
using namespace Tom; //先统一声明命名空间Tom里的所有标识符

x = 10; y = 20; //再通过标识符访问，访问时可以省略命名空间
fun1(); fun2();
```

通过这种方式访问方式是最简单直接的。

### 4、匿名命名空间

using 和 namespace都是C++语言保留的关键字，C++语言还有个默认的匿名的命名空间，如果程序员编写函数或全局变量，定义时没有定义在任何命名空间里，则默认就属于该匿名命名空间，C++标准库就引入了命名空间的概念，所有函数实体，例如外部函数、全局变量或对象等，都定义再命名空间std当中，使用这些函数实体，除了需要使用#include指令包含相应的头文件之外，还需要声明其命名空间，例如需要使用cin>>和cout<<对象输入输出数据，则除了需要用#include指令包含头文件<iostream>之外，还需要声明其命名空间std，就是using namespace std;的由来。

## 3.3 动态内存分配

动态内存分配又称为在堆分配，生存期由用户指定，分配灵活，但有内存泄露等问题，是一个在程序里面随机申请的内存。

在C语言中使用函数来实现内存的动态分配

- 分配内存：malloc函数
- 释放内存：free函数

C++语言提供了另外一种新的动态内存分配方法

- 分配内存：new运算符
- 释放内存：delete运算符

动态内存分配可以提高内存的使用率，内存的动态分配、访问和释放，都需通过指针变量来实现，C++针对单个变量和数组变量，new运算符和delete运算符使用语法有区别

### 1、基本的定义和释放方法

```c++
指针变量名 = new 数据类型（初始值）；
delete指针变量名；
```

**语法说明：**

- **数据类型**指定动态分配变量的数据类型；
- **（初始值）**指定所分配内存单元的初始值（用小括号括起来），及变量的初始化，如果不需要初始化，“**（初始值）**”则可以省略；
- 计算机执行**new**运算符时将按照数据类型指定的字节数分配内存空间并初始化，然后返回所分配内存单元的首地址，应当通过赋值语句将该首地址保存到一个预先定义好的同类型**指针变量**中；
- 计算机执行**delete**运算符时将按照指针变量中的地址释放指定的内存单元；

```c++
int *p; //为了动态分配一个int型变量，需预先定义好一个int型指针变量
p = new int; //使用new运算符动态分配一个int型变量，将所分配内存单元的首地址赋值给指针变量p

*p = 10; //通过指针变量p间接访问所分配的内存单元，向其中写入数据10
cout<<*p; //通过指针变量p间接访问所分配的内存单元
delete p; //内存使用完后，用delete运算符释放该内存空间
```

 上述语句可以简化为：

```c++
int *p = new int(10); //动态分配变量时进行初始化
cout<<*p; //通过指针变量p间接访问所分配的内存单元
delete p; //内存使用完后，用delete运算符释放该内存空间
```

### 2、一维数组的动态分配与释放

C++语法：

```c++
指针变量名 = new 数据类型[整数表达式]；
delete[]指针变量名；
```

语法说明：

- **数据类型**指定动态分配数组变量的数据类型；
- **表达式**指定一维数组的元素个数，用中括号“[]”括起来，表达式可以是单个常量、变量或是一个整数表达式，其结果必须为正整数。
- 计算机执行**new**运算符时将按照数据类型和元素个数分配相应字节的内存空间，然后返回所分配的内存单元的首地址，应当通过赋值语句将该首地址保存到一个预先定义好的同类型**指针变量**中，**特别注意：动态分配的数组变量不能初始化；**
- 计算机执行**delete**运算符时，将按照**指针变量**中的地址释放指定的内存单元，“[]”表示所释放的内存空间是一个数组，其中包含多个内存单元，应同时释放；

```c++
int *p = new int[5]; //动态分配一个int型一维数组变量，包含5个数组元素

*(p+1) = 10; //通过指针运算符访问第一个元素，向其中写入数据10
p[1] = 10	//或通过下标运算符访问第一个元素
cout << *(p+1); //通过指针运算符访问第一个元素，读取其中数据10并显示出来
cout<<p[1]; //或通过下标运算符访问第一个元素

delete[]p; //内存使用完后，用delete运算符释放该数组变量所分配的内存空间，将内存空间全部释放
```

实列：计算斐波那契额数列

```c++
#include <iostream>
using namespace std;

int main()
{
    int N; //定义一个int变量N
    cin >> N; //键盘输入要显示数列的前多少项，将数值保存在变量N中

    int *p = new int[N]; //动态创建包含N个元素的数组，用于保存数列的前N项
    p[0] = 0; p[1] = 1; //指定数列的前2项

    int n; //为循环语句定义好循环变量n
    for(n=2; n<N;n++) //使用循环结构计算处剩余的数列项
        p[n] = p[n-1] + p[n-2];//每一项等于其前2项之和
    
    for(n=0; n<N;n++) //使用循环结构遍历显示数组
    {
        cout << p[n] << ","; //各数列项用逗号隔开
        if((n+1)%5 == 0) cout<<endl; //一行显示5项，每5项一次换行
    }

    delete[]p; //数组使用结束，动态释放其内存空间
    return 0;
}
```

## 3.4 静态内存分配

与动态内存分配相对的就是静态内存分配，此时的内存在程序编译的时候已经分配好，并且在程序的整个运行期间都存在。全局变量，static变量等在此存储。

```c++
int x; //定义一个int型变量x，定义时指定数据类型和变量名
	  //计算机执行该语句为变量x分配一个4字节的内存单元
x = 10; //通过变量名访问所分配的内存单元，向其中写入数据10
cout<<x; //通过变量名x访问所分配的内存单元
```

## 3.5 在栈分配（局部变量）

堆栈是由编译器自动分配释放，存放函数的参数和局部变量的值（auto类型），操作方式类似于数据结构中的栈。栈的申请是由系统自动分配，如在函数内部申请一个局部变量int h,同时判断所申请空间是否小于栈的剩余空间，如果小于则为其开辟空间，为程序提供内存，否则将报异常提示栈溢出。





